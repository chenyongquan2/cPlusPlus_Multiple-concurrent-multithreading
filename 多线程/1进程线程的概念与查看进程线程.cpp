#include <iostream>

using namespace  std;

/*
一、并发、进程、线程的基本概念和综述
并发，线程，进程要求必须掌握

1.1 并发

两个或者更多的任务（独立的活动）同时发生（进行）：一个程序同时执行多个独立的任务；
以往计算机，单核cpu（中央处理器）：某一个时刻只能执行一个任务，由操作系统调度，每秒钟进行多次所谓的“任务切换”。并发的假象（不是真正的并发），
切换（上下文切换）时要保存变量的状态、执行进度等，一会切换回来要复原这些信息，存在时间开销；
随着硬件发展，出现了多处理器计算机：用于服务器和高性能计算领域。
台式机：在一块芯片上有多核（一个CPU内有多个运算核心，对于操作系统来说，每个核心都是作为单独的CPU对待的）：双核，4核，8核，10核（自己的笔记本是4核8线程的）。
能够实现真正的并行执行多个任务（硬件并发）
使用并发的原因：主要就是同时可以干多个事，提高性能
1.2 可执行程序

磁盘上的一个文件，windows下，扩展名为.exe；linux下，ls -la，rwx（可读可写可执行）
1.3 进程

运行一个可执行程序，在windows下，可双击；在linux下，./文件名
进程，一个可执行程序运行起来了，就叫创建了一个进程。进程就是运行起来的可执行程序。
1.4 线程
①

a)每个进程（执行起来的可执行程序），都有唯一的一个主线程
b)当执行可执行程序时，产生一个进程后，这个主线程就随着这个进程默默启动起来了
ctrl+F5运行这个程序的时候，实际上是进程的主线程来执行（调用）这个main函数中的代码
主线程与进程唇齿相依，有你必然有我，有我必然有你，没有你必然没有我(主线程的生命周期跟随着进程)
线程：用来执行代码的。线程这个东西，可以理解为一条代码的执行通路

②

除了主线程之外，可以通过写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方
每创建一个新线程，就可以在同一时刻，多干一个不同的事（多走一条不同的代码执行路径）
③

多线程（并发）
线程并不是越多越好，每个线程，都需要一个独立的堆栈空间（大约1M），线程之间的切换要保存很多中间状态，切换也会耗费本该属于程序运行的时间
必须使用多线程的案例

例如 服务器充值线程的还在等充值服务器返回充值结果(还在干活)，这时候如果其他玩家想抽卡，那么可以让抽卡线程负责抽卡。


//总结线程：
a)线程是用来执行代码的；
b)线程这东西理解为一条代码的执行通道(道路)，一个新线程代表一条新的通路。
c)一个进程自动包含一个主线程,主线程随着进程默默的启动并运行，我们可以通过编码来创建其他多个线程(子线程)
	//但是创建的数量最大都不建议超过200-300个，至于到底多少个合适，大家在实际的项目中不断调整和优化。有的时候线程多了，效率反而会降低(因为上下文切换占用了太多无意义的时间)
d)因为主线程是自动启动的，所以一个进程中至少也是有一个线程的（主线程）。进程和主线程感觉就是爹和儿子的关系。
e)说白了 多线程程序可以同时干多个事情，所以运行效率高(因为同时干了多个事情)，但是到底有多高，并不是一个很容易评估和量化的东西。


1.5 学习心得

开发多线程程序：一个是实力的体现，一个是商用的必须需求
线程开发有一定难度
C++线程会设计很多新概念
网络方向：网络通讯、网络服务器，多线程是绝对绕不开的

二、并发的实现方法
实现并发的手段：
a）通过多个进程实现并发
b）在单独的进程中，写代码创建除了主线程之外的其他线程来实现并发

2.1 多进程并发
两个或者更多个任务(独立的活动)同时发生(进行)
比如账号服务器一个进程，游戏服务器一个进程。(因为一个进行至少有一个线程(主线程))
服务器进程(eg 账号服务器，游戏逻辑服务器)之间存在通信（同一个电脑上：管道，文件，消息队列，共享内存）；（不同电脑上：socket通信技术）

2.2 多线程并发
线程：感觉像是轻量级的进程。每个进程有自己独立的运行路径，
但一个进程中的所有线程共享地址空间（共享内存），全局变量、全局内存、全局引用都可以在线程之间传递，所以多线程开销远远小于多进程(因为共享内存 可以直接拿来用)
	//共享内存带来了新问题，数据一致性问题；线程A 线程B
多进程并发和多线程并发可以混合使用，但建议优先考虑多线程技术
本课程中只讲多线程并发技术

2.3 总结:
//和进程相比，线程有如下优点：
1)线程启动速度更快，更轻量级;
2)系统资源开销更少，执行速度更快，比如共享呢村这种通信方式就比其他任何的通信方式都快。
//缺点:
1)使用起来会有一定难度，要小心处理数据的一致性问题。

三、C++11新标准线程库
1）以往 windows：CreateThread(), _beginthread(),_beginthreadexe()创建线程；linux：pthread_create()创建线程；不能跨平台
临界区，互斥量
2）POSIX thread(pthread):跨平台，但要做一番配置，也不方便
3）C++11
从C++11新标准，C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量


*/

int main(void)
{
	while (1)
	{
		printf("¼ÆËã»ú×é³ÉÔ­Àí\n");
	}
}
